package app.theater.areas;

import java.time.LocalDate;
import java.awt.event.ActionListener;
import java.util.*;
import app.theater.areas.locations.Seat;
import app.theater.performances.Performance;
import app.theater.performances.tickets.Ticket;

/**
 * Class SittingArea
 * 
 * @author Pablo Cuesta Sierra (pablo.cuestas@estudiante.uam.es), Pablo
 *         Fernández Alegre (pablo.fernandezalegre@estudiante.uam.es) and Álvaro
 *         Zamanillo Sáez (alvaro.zamanillo@estudiante.uam.es)
 *
 */
public class SittingArea extends SimpleArea {
	private static final long serialVersionUID = 6794915169355046671L;
	
	private int rows;
    private int columns;
    private Seat[][] seats;

    /**
     * Constructor of sitting areas
     * 
     * @param name    name of the sitting area
     * @param rows    rows of the area
     * @param columns columns of the area
     */
    public SittingArea(String name, int rows, int columns) {
        super(name);
        this.rows = rows;
        this.columns = columns;
        this.seats = Seat.initSeats(this);// initializes the seats (each with its row and col)
    }

    /**
     * Capacity of the area
     * @return capacity of the area
     */
    @Override
    public int getCapacity() {
        return rows * columns;
    }

    /**
     * Returns the list of tickets generated by this sitting area 
     * for the performance performance with the restriction specified
     * @param restriction percentage to be restricted
     * @param performance performance
     * @return list with the tickets generated 
     */
    @Override
    public List<Ticket> getTickets(double restriction, Performance performance) {
        List<Ticket> tickets = new ArrayList<>();
        int restricted=(int)(getCapacity()*((restriction)/100));
        LocalDate date = performance.getDate();
        int countRestricted = 0;

		for(int i = 0; i < this.rows; i++){
            for(int j = 0; j < this.columns; j++){
                Ticket t = new Ticket(this.seats[i][j], performance);
                if(seats[i][j].isDisabled(date)){
					t.restrict();
					countRestricted++;
                }
                tickets.add(t);
            }
		}   

        restrictRemainingTickets(this.getCapacity(), restricted, countRestricted, tickets);		

        return tickets;
    }

    /**
     * Helper method to restrict the remaining available tickets 
     * in case it is necessary.
     * The following algorithm restricts evenly throughout the available seats.
	 * Principle: let N be the number of remaining available seats: 
     *                                N =capacity-countRestricted
	 * 			  let K be the number of seats yet to restrict: 
     *                                K =restricted-countRestricted
	 * 			  then N = m*K + r, where m = floor(N/K), 
     *                 and 0 <= r < N (the remainder of N/K)
	 * 		--> we have to restrict one seat every (m+1) available seats, r times
	 * 							and one seat every  m    available seats until 
     *                          the end.
     * @param capacity the capacity
     * @param restricted number of tickets to restrict
     * @param countRestricted number of tickets already restricted
     * @param tickets list with the tickets
	 **/
    private static void restrictRemainingTickets(int capacity, int restricted, int countRestricted, List<Ticket> tickets){
        		
		int k = (restricted-countRestricted);
		
		if (k <= 0) {
			return;
		}
		
		int n = (capacity-countRestricted);
        int m = n/k;
        int r = n-m*k;
        int mcount = 0;
        int rcount = 0;
        
        for(Ticket t:tickets){
            if(t.isAvailable()){
				mcount++;
				if (((mcount == m+1) && (rcount < r)) || ((mcount == m) && (rcount >= r))){
                	rcount++;
                    mcount = 0;
                    t.restrict();
                }
            }
        }

    } 

    /**
     * Getter for the number of rows
     * @return number of rows
     */
    public int getRows(){
        return this.rows;
    }

    /**
     * Getter for the number of columns
     * @return number of columns
     */
    public int getColumns(){
        return this.columns;
    }

    /**
     * Gets the seat specified by the parameters
     * @param row row of the seat
     * @param column column of the seat
     * @return the seat
     */
    public Seat getSeat(int row, int column){
        return this.seats[row][column];
    }
    
    /**
     * Checks if the area is equal
     * @param o area to be checked
     * @return true iff equal
     */
    @Override
    public boolean equals(Object o){
        if(this==o){
            return true;
        }
        if((!super.equals(o)) || (!(o instanceof SittingArea))){
            return false;
        }
        return (((SittingArea)o).columns == this.columns) 
        		&& (((SittingArea)o).rows == this.rows); 
    }

    /**
     * Returns a representative string of the area
     * @return the string
     */
    @Override
    public String toString(){
        return "Sitting area: "+getName()+". Rows: "+rows+". Columns: "+columns+". Capacity: "+getCapacity();
    }
}
